= 高效程序员的45个习惯
:stem: latexmath
:icons: font
:source-highlighter: highlight.js
:sectnums:
:sectlinks:
:sectnumlevels: 4
:toc: left
:toc-title: 目录
:toclevels: 3  



== 态度决定一切

#选定了要走的路，就是选定了它通往的目的地。#

=== 做事

==== 最高优先级应该是解决问题

* 指责不能修复BUG
** 把矛头对准问题的解决办法，而不是人。


* 符合标准不是结果，过程符合标准并不意味结果是正确的。敏捷团队重结果胜于重过程。

==== 切身感受
** 勇于承认自己不知道答案，这会让人感觉放心。
** 一个重大的错误应该被当作一次学习而不是指责他人的机会。
** 团队成员在一起工作，应互相帮助，而不是互相指责

==== 平衡的艺术

** "这不是我的错"，这句话不对。“这都是你的错”，这句话更不对。
** 如果你没有犯过任何错误，就说明你可能没有努力去工作。
** 开发者和质量工程师争论某个问题是系统本身的缺陷还是系统增强功能导致的，通常没有多大的意义。与其如此，不如赶紧去修复它。
** 如果一个团队成员误解了一个需求、一个API调用，或者最近 一次会议做的决策，那么，也许就意味着团队的其他成员也有相同的误解。要确保整个团队尽快消除误解。
** 如果一个团队成员的行为一周伤害了团队，则他表现得很不职业，那么，他就不是帮助团队向解决问题的方向前进。这种情况下，我们必须要求他离开这个团队。
*** 不需要解雇他，但是他不能继续留在这个项目中。同时也要意识到，频繁的人员变动对整个团队的平衡也很危险。
** 如果大部分团队成员（特别是开发领导者）的行为都不职业，并且他们对团队目标都不感兴趣，你就应该主动从这个团队中离开，寻找更适合自己发展的团队。

=== 欲速则不达

==== 防微杜渐
** 在工作压力之下，不去深入了解真正的问题以及可能的后果，就快速修改代码，这样只是解决表面问题，最终会引发大问题。
** 短期看，它似乎是有效的。但从长远来看，它无异于穿越一片流沙，你也许侥幸超过了一半的路程（甚至更远），一切似乎者很正常。但是转眼间悲剧就发生了......
** 只要我们继续进行快速修复，代码的清晰就不断降低。一旦问题累积到一定程度，尝清晰的代码就不复存在，只剩一片混浊。很可能在你的公司就有人这样告诉你：“无论如何，千万不能碰那个模块的代码。写代码的那哥们儿已经不在这儿了，没有人看得懂他的代码。”这些代码根本没有清晰度可言，它已经成为一团迷雾，无人能懂。

==== 要理解开发过程

** 尽管我们在谈论理解代码，特别是在修改代码之前一定要很好地理解它，然而同样道理，你也需要了解团队的开发方法或者开发过程。
** 你必须要理解团队采用的开发方法。你必须理解如何恰如其分地使用这种方法，为何它们是这样的，以及如何成为这样的。
** 只有理解了这些问题，你才能进行有效的改变。
** 如果在你的团队中有这样的事情 发生，那么你是不可能 敏捷的。但是敏捷方法中的一些技术可以阻止这样的事情发生。

==== 不要孤立地编码
** 孤立非常危险，不要让开发人员完全孤立地编写代码。如果团队在员花些时间阅读其他同事它的代码，他们就能确保代码是可读和可理解的，并且不会随意加入这些“+1或-1”的代码。阅读代码的频率越高越好。
** 实行 #代码复审# ，不仅有助于代码更好理解，而且是发现bug最有效的方法之一。
** 单元测试是防止代码难懂的重要技术。单元测试帮助你很自然地把代码分层 ，分成很多可管理的小块，这样就会得到设计更好、更清晰的代码
** 更深入项目的时候，你可以直接阅读单元测试--它们是一种可执行的文档。有了单元测试，你会看到更小、更易于理解 的代码模块，运行和使用代码，能够帮助你彻底理解这些代码。

* #不要除快速的简单修复中。# 要投入时间和精力保持代码的整洁、敞亮。

==== 切身感受
** 在项目中，代码应该是很亮堂的，不应该有黑暗死角。你也许不知道每块代码的每个细节，或者每个算法的每个步骤，但是你对整体的相关知识有很好的了解。没有任何一块代码被警戒线或者“切勿入内”的标志隔离开。

==== 平衡的艺术

** 你必须要理解一块代码是如何工作的，但是不一定需要成为一位专家。只要你能使用它进行有效的工作就足够了，不需要把它当作毕生事业。
** 如果有一位团队成员宣布，有一块代码其他人都很难看懂，这就意味着任何人（包括原作者）都很验证维护它。请让农业经济变得简单些。
** 不要急于修复一段没能真正理解的代码。这种+1/-1的病症于无形，但是很快就会让代码一团糟。要解决真正的问题，不要治标不治本。
** 所有的大型系统都非常复杂，因此没有一个人能完全明白所有的代码。除了深入了解你正在开发的那部分代码外，你还需要从更高的层面来了解大部分代码的功能，这样就可以理解 系统各个功能块之间是如何交互的。


=== 对事不对人

==== 要专业而不是自我

* 在一个需要紧密合作的开发团队中，如果能稍加注意礼貌对待他人，将会有益于整个团队关注真正有价值的问题，而不是勾心斗角，误入歧途。
* 我们每个人都能有一些极好的创新想法，同样也会萌生一些很愚蠢的想法。
* 如果你有准备提出一个想法，却担心有可能被嘲笑，或者你要提出一个建议，却担心自己丢面子，那么你就不会自动提出自己的建议了。然而好的软件开发作品和好的软件设计，都需要大量的创造力和没空力。分享并融合各种不同的想法和观点，远远胜于单个想法为项目带来的价值。

==== 消极扼杀创新
* 必须把重点放在解决问题上，而不是去极力证明谁的主意更好。
* 在团队中，不个人只是智商高是没有用的，如果他还很顽固并且拒绝合作，那就更糟糕。在这样的团队中，生产率和创新都会濒临灭亡的边缘。
* 我们每个人都会有好的想法，也会有不对的想法，团队中的每个人都需要自由地表达观点。即使你的建议不被全盘接受，也能对最终解决问题有所帮助。
* 不要害怕受到批评。记住，任何一个专家都是从这里开始的。

==== 团队决策的骆驼

* 集体决策确实非常有效，但也有一些最好的创新源于很有见地 的个人的独立思考。
* 如果你是一个有远见的人，就一定要特别尊重别人的意见。
* 你是一个掌舵者，一定要把握方向，深思熟虑，吸取各方的意见。
* 另一个极端是缺乏生气的委员会，每个设计方案都需要全票通过。这样的委员会是小题大做，如果让他们造一匹木马，很可能最后造出的是骆驼。
* 能容纳自己并不接受的想法，表明你的头脑足够有学识。

==== 设定最终期限
* 如果正在参加设计方案讨论会，或者是寻找解决方案时遇到问题，请设定一个明确的最终期限，例如午饭时间或者一天的结束。这样的时间限制可以该上人们陷入无休止的理论争辩中，保证团队工作的顺利进行。
* 没有最好的答案，只有更合适的方案。设计期限能够在为验证的时候接果断做出决策，让工作可以继续进行。

==== 逆向思维
* 团队中的每个成员都应该意识到权衡的必要性。一种客观对待问题的办法是：先积极地看到它的下面，然后再努力地从反而去认识它。目的是要找出优点最多缺点最少的那个方案，而这个好办法可以尽可能地发现其优缺点。这也有且少带个人感情。

==== 设立仲裁人
* 在会议的开始，选择一个仲裁人作为本次会议的决策者。
* 每个人都要有机会针对 问题畅所欲言。
* 仲裁人的责任就是确保每个人都有发言机会，并维持会议的正常进行。
* 仲裁人可以防止明星员工操纵会议，并及时打断假太空式发言。
* 如果你没有积极参与这次讨论活动，那么你最好退一步做好会议的监督者。
* 仲裁人应该专注于调停，而不是发表自己的观点（理想情况下不应该在整个项目中有既得利益）。
* 这项目任务不需要严格的技术技能，需要的是和他人打交道的能力。

==== 支持已经做出的决定

* 一旦方案被确定（不管是什么样的方案），每个团队成员都必须通力合作，努力实现这个方案。
* 每个人都要时刻记住，我们的目标是让项目成功满足用户需求。
* 客户并不关心这是谁的主意---他们关心的是这个软件是否可以工作，并且是否符合他们的期望。
* 结果最重要
** 设计充满了妥协（生活本身也是如此）

#对事不对人#。 让我们骄傲的应该是解决了问题，而不是比较出谁的主意更好。

==== 切身感受
* 一个团队能够很公正地讨论一些方案的优点和缺点，你不会因为拒绝了有太多缺陷的方案而伤害别人，也不会因为采纳了某个不甚完美（但是更好的）解决方案而被人忌恨。

==== 平衡的艺术

* 尽力贡献自己的好想法，如果你的想法没有被采纳也无需生气。不要因为只是想体现自己的想法而对拟定的好思路画蛇添足。
* 脱离实际的反方观点会使争论变味。若对一个想法有成见，你很容易 提出一堆不太可能 发生或不太实际 的情形去批驳它。这时，请先扪心自问：类似问题以前发生过吗？是否经常发生？
* 也就是说，像这样说是不够的：我们不能采用这个方案，因为数据库厂商可能会倒闭。或者：用户绝对 不会接受那个方案。你必须要评判那些场景发生的可能 性有多大。想要支持或者反驳一个观点，有时候你必须先做一个原型或者调查出它有多少的同意者或者反对者。
* 在开始寻找最好的解决方案之前 ，大家对”#最好#“的含义要先达成共识。在开发者眼中的最好，不一定就是用户认为最好的，反之亦然。
* 只有更好，没有最好。
* 不带个人情绪并不是要盲目地接受所有的观点。用合适的词和理由去解释为什么你不赞同这个观点或方案，并提出明确的问题。

=== 排除万难，奋勇前进
==== 践行良好习惯
* 你深知怎样做才是正确的，或者至少知道目前的做法是错误的。要有勇气向其他的项目成员、老板或者客户解释你的不同观点。当然这并不容易。也许你会拖延项目的进度，冒犯项目经理，甚至惹恼投资人。但你都要不顾一切，向着正确的方向奋力前进。

#做正确的事。#要诚实，要有勇气去说出实情，有时，这样做很困难，所以我们要有足够的勇气。

==== 切身感受
* 勇气会让人觉得胡点不自在，提前鼓足勇气更需要魄力。但有些时候，它是扫除障碍的唯一途径，否则 问题就会进一步恶化下去。鼓起你的勇气，这能让你从恐惧中解脱出来。

==== 平衡的切艺术
* 如果你说天快要塌下来了，但其他团队成员都不赞同。反思一下，也许你是正确的，但你没有解释清楚自己的理由。
* 如果你说天快要塌下来了，但其他团队成员都不赞同。认真考虑一下，他们也许是对的。
* 如果设计或代码中出现了奇怪的问题，花时间去理解 为什么代码会是这样的。如果你找到了解决办法，但代码仍然信人费解，唯一的解决办法就是重构代码，让它可读性更强。学科建设我起码有马上理解那段代码，不要轻易地否定和重写它们。那不是勇气，而是鲁莽。
* 当你有勇敢地站出来时，如果受到了缺乏背景知识的抉择者的抵制，你需要用他们能够听懂的话语表达。”更清晰的代码“是无法打劫生意人的。节约资金、获得更好的投资回报，避免诉讼以及增加用户利益，会让论点更有说服力。
* 如果你在压力下要对代码质量作出妥协，你可以指出，作为一名开发者，你没有职权毁坏公司的资产（所有的代码）。

== 学无止境
#即使你已经在正确的轨道上，但如果只是停止不前，也仍然会被淘汰出局。#

=== 跟踪变化
* #迭代和增量式的学习。# 每天计划用一段时间来学习新技术，它不需要很长时间，但需要经常进行。讲下那些你想学习的东西--当你听到一些不熟悉的术语或者短语时，简要地把它记录下来。然后在计划的时间中深入研究它。
* #了解最新行情。# 互联网上有大量关于学习新技术的资源 。阅读社区讨论和邮件列表，可以了解其他人遇到的问题，以及他们发现的很好的解决方案。选择一些公认的优秀技术博客，经常去读一读，以了解那些顶尖的博客作者们正在关注什么。
* #参加本地的用户组活动。# Java、Ruby、.NET、过程改进、面向对象设计，以及其他的各种技术在很多地区都会有用户组。听讲座，然后积极加入到问答环节中。
* #参加研讨会议。# 计算机大会以在世界各地举行，许多知名的顾问或作者主持研讨会或者课程。这些聚会是向专家学习的最直接的好机会。
* #如饥似渴地阅读。# 找一些关于软件开发和非技术主题的好书，也可以是一些专业的期刊和商业杂志，甚至是一些大人媒体新闻。

* #跟踪技术变化。# 你不需要精通 所有技术，但需要清楚知道行业的动向，从而规划你的项目和职业生涯。

==== 切身感受
* 你能嗅到将要流行的新技术，知道它们已经发布或投入使用。如果必须要把工作切换到一种新的技术领域，你能做到。

==== 平衡的艺术
* 许多新想法从未变得羽翼丰满，成为有用的技术。即使是大型、热闹和资金充裕的项目也会有同样的下场。你要正确把握自己投入的精力。
* 你不可能精通每一项技术，没有必要去做这样的尝试。只要你在某些方面成为专家，就能使用同样的方法，很容易成为新领域的专家。
* 你要明白为什么需要这项新技术--它试图解决什么样的问题？它可以被 用在什么地方？
* 避免在一时冲动的情况下，只是因为想学习而将应用切换到新的技术、框架或开发语言。在做决策之前 ，你必须评估新技术的优势。开发一个小的原型系统，是对会技术狂热者的一剂良药。

=== 对团队投资

* 一个学习型的团队才是较好的团队。
* #提供你和团队学习的更好平台。# 通过会议可以增进每个人的知识和技能，并帮助大家聚集在一起进行沟通交流。唤起人们对技术和技巧的激情，将会对项目在有裨益。

==== 切身感受
* 这样做，会让每个人都觉得自己越来越聪明。整个团队都要了解新技术，并指出如何使用它，或者指出需要注意的缺陷。

==== 平衡的艺术
* 读书小组逐章一起阅读一本书，会非常有用，但是要选好书。
* 不是所有的讲座都能引人入胜，有些甚至显得 不合时宜。不管怎么样，都要未雨绸缪；
* 尽量让讲座走入团队中。
* 坚持 有计划有规律地举行讲座。持续、小步前进才是敏捷。稀少、间隔时间长的马拉松式会议非敏捷也。
* 如果一些团队成员因为吃午饭而缺席，用美食引诱他们。
* 不要局限于纯技术的图书和主题，相关的非技术主题（项目估算、沟通技巧等）也会对团队有帮助。

=== 懂得丢弃

#学习新的东西，丢弃旧的东西。# 在学习一门新技术的时候，要丢弃会阻止你前进的旧习惯。毕竟，汽车要比马车车厢强得多。

==== 切身感受
* 新技术会让人感到有一点恐惧。你确实需要学习很多东西。已有的技能和习惯为你打下了很好的基础，但不能依赖它们。

==== 平衡的艺术
* 沉舟侧畔千帆过，病树前头万木春。要果断丢弃旧习惯，一叶遵循过时的旧习惯会危害你的职业生涯。
* 不是完全忘记旧的习惯，而是只在使用适当的技术时才使用它。
* 对于所使用的语言，要总结熟悉的语言特性，并且比较这些特性在新语言或新版本中有什么不同。

=== 打破砂锅问到底

#不停地问为什么。# 不能只满足于别人告诉你的表面现象。要不停地提问直到你明白问题的根源。

==== 切身感谢
* 这就好比是从矿石中采掘贵重的珠宝。你不停地筛选掉无关的物质，一次比一次深入，直到找到发光的宝石。你要能感觉到真正地理解 了问题，而不是只知道表面的症状。

==== 平衡艺术
* 你可能 会跑题，问了一些与主题无关的问题。就好比是，如果汽车启动不了，你问是不是轮胎出了问题，这是没有任何帮助的。问“为什么”，但是要问到点子上。
* 当你问“为什么“的时候，也许你会被反问：”为什么你问这个问题？“在提问之前，想好你提问的理由，这会有助于你问出恰当 的问题。
* ”这个，我不知道“是一个好的起点，应该由此进行更进一步的调查，而不应在此戛然结束。

=== 把握开发节奏

==== 时间盒
* 敏捷开发者可以从多方面得到反馈：用户、团队成员和测试代码。这些反馈会帮助你驾驭项目。但是时间本身就是一个非常重要的反馈。
* 许多的敏捷技巧来源于时间盒--设定一个短时的期限，为任务设定不能延长的最终期限。你可以选择我放弃其他方面的任务，但是最终期限是不变的。你可能 不知道完成所有的任务需要多个时间盒，但每个时间盒必须是短期的、有限的，并且要完成具体的目标。
* 当你遇到艰难抉择的时候，固定的时间期限会促使你做决定。你不能在讨论或功能上浪费很多时间，这些时间可以用于具体的工作。时间盒会帮助你一直前进。

#解决任务，在事情变得一团糟之前。# 保持事件之间稳定重复的间隔，更容易解决觉的重复任务。

==== 切身感受
* 项目开发需要有一致和稳定的节奏。编辑，运行测试，代码复审，一致的迭代，然后发布。如果知道什么时候开始下一个节拍，跳舞会更加容易。

==== 平衡的艺术
* 在每天结束的时候，测试代码，提交代码，没有残留的代码。
* 不要搞得经常加班。
* 以固定、有规律的长度运行迭代。也许刚开始你要调整迭代的长度，找到团队最舒服可靠的时间值，但之后 就必须要坚持。
* 如果开发节奏过于密集，你会精疲力竭的。一般来说，当与其他团队合作时，你需要减慢开发节奏。因为人们常说，互联网时间发展太快，有害健康。
* 有规律的开发节奏会暴露很多问题，让你有更多鼓起勇气的借口。
* 就像是减肥一样，一点点的成功也是一个很大的激励。小而可达到的目标会让每个人全副前进。庆祝每一次难忘的成功：共享美食和啤酒或者团队聚餐。


== 交付用户想要的软件
#没有任何计划在遇敌后还能继续执行。#

=== 让客户做决定
==== 决定什么不该决定
* 开发者及项目经理能做的一个最重要的决定就是：判断哪 些是自己决定不了的，应该让企业主做决定。你不需要自己给业务上的关键问题做决定。毕竟那不是你的事情。
* 如果遇到了一个问题，会影响到系统的行为或者如何使用系统，把这个问题告诉业务负责人。如果项目领导或经理试图全权负责这些问题，要委婉地劝说他们，这些问题最好 还是和真正的业务负责人或者客户商议。
* 当你和客户讨论问题的时候，准备好几种可靠择的方案。不是从技术的角度，而是从业务的角度，但要每种方案的优缺点，以及潜在的成本和利益。和他们讨论每个选择对时间的预算影响，以及如何权衡。无论他们做出了什么决定，他们必须接受它，所以最好让他们了解一切之后 再做这些决定。如果事后他们又想要其他的东西，可以公正地就成本和时间重新谈判。毕竟这是他们的决定。

#让你的客户做决定。# 开发者、经理或者业务分析师不应该做业务方面的决定。用业务负责人能够理解的语言，向他们详细解释遇到的问题，并让他们做决定。

==== 切身感受
* 业务应用需要开发者和业务负责人互相配合来开发。这种配合的感觉就该像一种良好的，诚实的工作关系。

==== 平衡的艺术
* 记录客户做出的决定，并注明原因。好记性不如烂笔头。可以使用工程师的工作日记或日志、Wiki、邮件记录或者问题跟踪数据库。但是也要注意，你选择的记录方法不能太笨重或者太繁琐。
* 不要用低级别和没有价值的问题打扰繁忙的业务人员。如果问题对他们的业务没有影响，就应该是没有价值的。
* 不要随意假设低级别的问题不会影响他们的业务。如果能影响他们的业务，就是有价值的问题。 
* 如果业务负责人回答”我不知道“，这也是一个称心如意的答案。也许是他们还没有想到那么远，也许是他们只有看到运行的实物才能评估出结果。尽你所能为他们提供建议，实现代码的时候也要考虑可能出现的变化。


=== 让设计指导而不是操纵开发

==== 设计满足实现即可，不必过于详细
* 如果设计师们把自己的想法绘制成精美的文档，然后把它们扔给程序员去编码，那会发生什么？程序员会在压力下，完全按照设计或者图画的样子编码。如果系统和已有代码的现状表明接收到的设计不够理想，那怎么办？太糟糕了！时间已经花费在设计上，没有工夫回头重新设计了。团队会死撑下去，用代码实现了明明知道是错误的设计。这听起来是不是很愚蠢？是够愚蠢的，但是有一些公司真的就是这样做的。
* 严格的需求--设计--代码--测试--开发流程源于理想化的 #瀑布式# 开发方法，它导致在前面进行了过度的设计。这样在项目的生命周期中，更新和维护这些详细的设计文档变成了主要工作，需要时间和资源 方面的巨大投资，却只有很少的回报。我们本可以做得更好。
* 设计可以分为两层：#战略# 和 #战术# 。前期的设计属于战略，通常只有在没有深入理解 需求的时候需要这样的设计。更确切地说，它应该只描述总体战略不应深入到具体的细节。

==== 做到精确
* 如果你自己都不清楚所谈论的东西，就根本不可能精确地描述它。
* 战略级别的设计不应该具体说明程序方法、参数、字段、对象交互精确顺序的细节。那应该留到战术设计阶段，它应该在项目开发的时候，再具体展开。

==== 战略设计与战术设计
* 良好的战略设计应该扮演地图的角色，指引你向正确的方向前进。任何设计仅是一个超跑点：它就像你的代码一样，在项目的生命周期中，会不停地进一步发展和提炼。

#好设计是一张地图，它也会进化。# 设计指引你向正确的方向前进，它不是殖民地，它不应该标识 具体的路线。你不要被设计（或者设计师）操纵。

==== 切身感受
* 好的设计应该是正确的，而不是精确的。也就是说，它让所有人一切必须是正确的，不应该涉及不确定或者可能 会发生变化 的细节。它是目标，不是具体的处方。

==== 平衡的艺术
* ”不要在前期做大量的设计“并不是说不要设计。只是说在没有经过真正的代码验证之前，不要陷入太多的设计任务。当对设计一无所知的时候，投入编码也是一件危险的事。如果深入编码只是为了学习或创造原型，只要你随后能把这些代码扔掉，那也是一个不错的办法。
* 即使初始的设计到后面不再管用，你仍需设计：设计行为是无价的。正如美国总统艾森豪威尔所说：”计划是没有价值的，但 #计划的过程# 是必不可少的。”在设计过程中学习是有价值的，但设计本身也许没有太大的用处。
* 白皙、草图、使得贴都是非常好的设计工具。复杂的建模工具只会让你分散精力，而不是启发你的工作。

=== 合理地使用技术
==== 盲目地为项目选择技术框架，就好比是为了少交税而生孩子
* #这个技术框架真能解决这个问题吗？# 是的，也许这是显而易见的。但是，这个技术真能解决你面临的那个问题吗？或者，更尖锐一点说，你是如何评估这个技术的？是通过市场宣传还是道听途说？要确保它能解决你的问题，并没有任何的毒副作用。如果需要，先做一个小的原型。
* #你将会被它拴住吗？# 一些技术是贼船，一旦你使用了它。就会被 它套牢，再也不可能回头了。它缺乏 #可取消性# ,当条件发生变化 时，这可能 对项目有致使打击。我们要考虑它是开放技术还是专利技术，如果是开放的技术，那又开放到什么程度？
* #维护成本是多少？# 会不会随着时间的推移，它的维护成本会非常昂贵？毕竟，方案的花费不应该高于要解决的问题，否则 就是一次失败的投资。我们听说，有个项目的合同是支持一个规则 引擎，引擎一年的维护费用是5万美元，但是这个数据库只有30条规则 。这也太贵了。
* 当你在考察一个框架（或者任何技术）的时候，也许会被它提供的各种功能吸引。接着，在验证是否使用这个框架的时候，你可能只会考虑已经发现的另外一些功能。但是，你真的需要这些功能吗？也许为了迎合你发现的功能，你正在为它们找问题。这很像站在结账处一时冲动而买些无用的小零碎。

==== 不要开发你能下载到的东西
* 如果你发现自己在做一些花哨的东西（比如从头创建自己的框架），那就醒醒吧，闻闻烟味有多大，马上该起火了。你的代码写得越少，需要维护的东西就越少。

#根据需要选择技术。# 首先决定什么是你需要的，接着为这些具体的问题评估使用技术。对任何要使用的技术，多问一些挑剔的问题，并真实地作出回答。

==== 切身感受
* 新技术就应该像是新的工具，可以帮助你更好地工作，它自己不应该成为你的工作。

==== 平衡的艺术
* 也许在项目中真正评估技术方案还为时太早。那就好。如果你在做系统原型并要演示给客户看，也许一个简单的散列表就可以代替数据库了。如果你还没有足够的经验，不要急于决定用什么技术。
* 每一门技术都会有优点和缺点，无论它是开源的还是商业产品、框架、工具或者语言，一定要清楚它的利弊。
* 不要开发那些你容易 下载到的东西。虽然有时需要从最基础开发所有你需要的东西，但那是相当危险和昂贵的。

=== 保持可以发布

==== 已提交的代码应该随时可以行动
* 任何时候只要你没有准备好，那就是敌人进攻你的最佳时机。好好想一想，你的项目进入不可发布状态的频率是多少？你的源代码服务器中的代码，是不是像圣安那在那个决定性的黄昏一样--没有进行编队，遇到紧急情况无法立即启动。
* 在团队里工作，修改一些东西的时候必须很谨慎。你要时刻警惕，每次改动都会影响系统的状态和整个团队的工作效率。在办公室的厨房里，你不能容忍任何人乱丢垃圾，为什么就可以容忍一些人给项目带来垃圾代码呢？
* #在本地运行测试。# 先保证你完成的代码可以编译，并且能通过所有的单元测试。接着确保系统中的其他测试都可以通过。
* #检出最新的代码。# 从版本控制系统中更新代码到最新的版本，再编译和运行测试。这样往往会发现让你吃惊的事情：其他人提交的新的代码和你的代码发生了冲突。
* #提交代码。# 现在是最新的代码了，并且通过了编译和测试，你可以提交它们了。

#保持你的项目时刻可以发布。# 保证你的系统随时可以编译、运行、测试并立即部署。

==== 切身感受
* 你会觉得，不管什么时候，你的老板、董事长、质量保障人员、客户或者你的配偶来公司参观项目的时候，你都能很自信并毫不犹豫地给他们演示最新构建的软件。你的项目一直处于可以运行的稳定状态。

==== 平衡的艺术
* 有时候，做一些大的必读以后，你无法花费太多的时间和精力去保证系统一直可以发布。如果总共需要一个月的时间才能保证它一周内可以发布，那就算了。但这只应该是例外，不能养成习惯。
* 如果你不得不让系统长期不可以发布，那就做一个（代码和架构的分支版本），你可以继续进行你的实验，如果不行，还可以撤销，从头再来。千万不能让系统即不可以发布，又不可以撤销。

=== 提早集成，频繁集成

==== 你能集成并且独立
* 集成和独立不是互相矛盾的，你可以一边进行集成，一边进行独立开发。
* 使用mock对象来隔离对象之间的依赖关系，这样在集成之前就可以先做测试，用一个mock对象模拟真实的对象（或者子系统）。就像是拍电影时在光线的掩饰下使用替身一样，mock对象就是真实对象的替身，它并不提供真实对象的功能，但是它更容易控制，能够模仿需求的行为，使测试更加简单。

==== 决不要做大爆炸式的集成
* 当早期 进行集成的时候，你会看到子系统之间的交互和影响，你就可以估算它们之间通信和共享的信息数据。你越早弄清楚这些问题，越早解决它们，工作量就越小。就好比是，刚开始有3个开发者，开发着5万行的代码，后来是5000个开发者进行30000万行代码的开发。相反，如果你推迟集成的时间，解决这些问题就会变得很难，需要大量和大范围地修改代码，会造成项目延期和一片混乱。

#提早集成，频繁储存。# 代码集成是主要的风险来源。要想规避这个风险，只有提早集成，持续而有规律地进行集成。

==== 切身感受
* 如果你真正做对了，集成就不再会是一个繁重的任务。它只是编写代码周期中的一部分。集成时产生的问题，都会是小问题并且容易解决。

==== 平衡的艺术
* 成功的集成就意味着所有的单元测试不停地通过。正如医学界希波克拉底的誓言：首先不要造成伤害。
* 通常，每天要和团队其他的成员一起集成代码好几次，比如平均每天5-10次，甚至更多。但如果你每次修改一行代码就集成一次，那效用肯定会缩水。如果你发现自己的大部分时间都在集成，而不是写代码，那你一定是集成得过于频繁了。
* 如果你集成得不够频繁（比如，你一天集成一次，一周一次，甚至更糟。）也许就会发现整天在解决代码这段感情带来的问题，而不是在专心写代码。如果你集成的问题很大，那一定是做得不够频繁。
* 对那些原型和实验代码，也许你想要独立开发，而不要想在集成上浪费时间。但是不能独立开发大户型的时间，一旦你有了经验，就要快速地开始集成。

=== 提早实现自动化部署

==== 质量保证人员应该测试部署过程
* 如果现在你还是手工帮助质量保证人员安装应用，花一些时间，考虑如何将安装过程自动化。这样只要用户需要，你就可以随时为他们安装系统。要提早实现它，这样让质量保证团队即可以测试应用，又可以测试安装过程。如果还是手工安装应用，那么最后把应用部署到生产环境时会发生什么呢？就算公司给你加班费，你也不愿意为不同用户的机器或不同地点的服务器上一遍又一遍地安装应用。
* 有了自动化部署系统后，在项目开发中的整个过程中，会更容易 适应互相依赖的变化 。很可能 你在安装系统的时候，会忘记添加需要的库或组件--在任意一台机器上运行自动化安装程序，你很快就会知道什么丢失了。如果因为缺少了一些组件或者库不兼容而导致安装失败，这些问题会很快浮现出来。

==== 从第一天起就开始交付
* 一开始就进行全面部署，而不是等到项目的后期，这会有很多好处。事实上，有些项目在正式开发之前 ，就设计好了所有的安装环境。

#一开始就实现自动化部署应用。# 使用部署系统安装你的应用，在不同的机器 上用不同的配置文件测试依赖的问题。质量保证人员要像测试应用一样测试部署。

==== 切身感受
* 有些工作都应该是无形的。系统的安装或者部署应该简单、可靠及可重复。一切都很自然。

==== 平衡的艺术
* 一般产品在安装的时候，都需要有相应的软、硬件环境。比如：JAVA的某个版本、外部数据库或者操作系统。这些环境的不同很可能 会导致很多技术支持。所以检查这些依赖关系，也是安装过程的一部分。
* 在没有询问并征得用户的同意之前，安装程序绝对不能删除用户的数据。
* 部署一个紧急修复的BUG应该很简单，特别是在生产服务器的环境中。你知道这会发生，而且你不想在压力之下 ，在凌晨3点半，你还在手工部署系统。
* 用户应该可以安全并且完整地卸载安装程序，特别是在质量保证人员的机器环境中。
* 如果维护安装脚本变得很困难，那很可能是一个早期 警告，预示着--很高的维护成本（或者不好的设计决策）。
* 如果你打算把持续部署系统和产品CD或者DVD记录机连接到一起，你就可以自动地为每个构建制作出一个完整且有标签的光盘。任何人想要最新的构建，只要从架子上拿最上面的一张光盘安装即可。

=== 使用演示获得频繁反馈
==== 需求就像是流动着的油墨
* 你时常会听到一些人想要冻结需求。但是，现实世界中的需求就像是流动着的油墨。你无法冻结需求，正如 你无法冻结市场、单键、知识、进货或者成长一样。就算你真的冻结了，也很可能是冻结了错的东西。如果你期望用户在项目开始之前，就能给你可靠和明确的需求，那就大错特错了，赶快醒醒吧！
* 没有人的思想和观点可以及时冻结，特别是项目的客户。就算是他们已经告诉你想要的东西了，他们的期望和想法还是不停地进货--特别是当他们在使用新系统的部分功能时，他们才开始意识到它的影响和可能 发生的问题。这就是人的本性。
* 作为人类，不管是什么事情 ，我们都能越做越好，不过是以缓慢而逐步的方式。你的客户也一样。在给了你需求之后 ，他们会不停地研究这些功能，如何 才能让它们变得更好使用。如果，你觉得自己要做的所有工作就是按照用户的最初需求，并实现了它们，但是在交付的时候，需求已经发生了变化 ，你的软件可能不会另他们满意。在软件开发过程中，你将自己置于最大的风险中：你生产出了他们曾经要求过的软件，但却不是他们现在真正想要的。那最后的结果就是：惊讶、震惊和失望，而不是满意。
* 你的客户的期望就像宇宙飞船的实际位置。软件开发的成功就在于最后你离客户的期望有多近。你计算的每个精确位置，就是一个给客户演示目前已经完成功能的机会，也正是得到用户反馈的时候。在你动向进入下一段旅程的时候，这些反馈可以用来纠正你的方向。
* 我们经常看到，给客户演示所完成功能的时间与得到客户需求的时间间隔越长，那么你就会离最初需求越来越远。
* 应该定期地，每隔一段时间，例如一个迭代的结束 ，就与客户会晤，并且演示你已经完成的功能特性。
* 如果你能与客户频繁协商，根据他们的反馈开发，每个人都可以从中受益。客户会清楚你的工作进度。反过来，他们也会提炼需求，然后趁热反馈到你的团队中。这样，他们就会基于自己进化的期望和理解 为你导航，你编写的程序也就越来越接近他们的真实需求。客户也会基于可用的预算和时间，根据你们真实的工作进度，排列任务的优先级。
* 较短的迭代周期，会对频繁的反馈有负面影响吗？也许你会觉得，使用短的迭代周期会使工作变慢，延迟项目的交付。
* 让我们从这个角度思考：两年来一直拼命地开发项目，直到快结束 的时候，你和你的客户才发现一个基础功能有问题，而且它是一个核心的需求。你以为缺货订单是这样处理的，但这完全不是客户所想的东西。现在，两年之后 ，你完成了这个系统，写下了数据百万行的代码，却背离了客户的期望。再么说，两年来幸苦写出来代码有想当大部分要重写，代价是沉重的。
* 想反，如果你一边开发，一边向他们演示刚完成的功能。项目进展了两个月的时候，他们说：”等一下，缺货订单根本不是这么一回事。“ 于是，召开一个紧急会议：你重新审查需求，评估要做多大的改动。这时只要付很小的代价，就可以避免灾难了。
* 要频繁地获得反馈。如果你的迭代周期是一个季节或者一年，就应该把周期缩短到一周或者两周。完成了一些功能和特征之后，去积极获得客户的反馈。

==== 维护项目术语表
* 不一致的术语是导致需求误解的一个主要原因。企业喜欢用看似普遍浅显的词语来表达非常具体、深刻的意义。
* 我宣传词这看到这样的事情 ：团队中的程序员们，使用了和用户或者业务人员不同的术语，最后因为”阻抗失调“导致BUG和设计错误。
* 为了户名这类问题，需维护一份项目术语表。人们应该可以公开访问它，一般是在企业内部网或者Wiki上。这听起来似乎是一件小事情--只是一个术语列表及其定义。但是，它可以帮助你，确保你真正地和用户进行沟通。
* 在项目的开发过程中，从术语表中为程序结构--类、方法、模型、变量等选择使合适的名字，并且要检查和确保这些定义一直符合用户的期望。

#清晰可见的开发。# 在开发的时候，要保持应用可见（而且客户心中也要了解）。每隔一周或者两周，邀请所有的客户，给他们演示最新完成的功能，积极获得他们的反馈。

==== 切身感受
* 项目启动了一段时间之后 ，你应该进入一种舒适的状态，团队和客户建立了一种建康的富有创造性的关系。
* 突发事件应极少发生。客户应该能感觉到，他们可以在一定程度上控制项目的方向。

==== 跟踪问题
* 随着项目的进展，你会得到很多反馈--修正、建议、变更要求、功能增强、BUG修复等。要注意的信息很多。随机的邮件和潦草的告示贴是无法应付的。所以要有一个跟踪系统记录所有这些日志，可能是用Web界面的系统。

==== 平衡的艺术
* 当你第一次试图用这种方法和客户一起工作的时候，也许他们被这么多的发布吓到了。所以，要让他们知道，这些者阳内部的发布（演示），是为了他们自己的利益，不需要发布给全部的最终用户。
* 一些客户，也许会觉得没有时间应付每天、每周甚至是每两周的会议。毕竟，他们还有自己的全职工作。
* 所以要尊重客户的时间。如果客户只可以接受一个月一次会议，那么就定一个月。
* 一些客户的联络人的全职工作就是参加演示会议。他们巴不得每隔一小时就有一次演示和反馈。你会发现这么频繁的会议很难应付，而且还要开发代码让他们看。缩减次数，只有在你做完一些东西可以给他们演示的时候，大家才碰面。
* 演示是用来让客户提出反馈的，有助于驾驭项目的方向。如果缺少功能或者稳定性的时候，不应该拿来演示，那只能让人生气。可以及早说明期望的功能：让客户知道，他们看到的是一个正在开发中的应用，而不是一个最终已经完成的产品。


=== 使用短迭代，增量发布
* 统一过程和敏捷方法都使用迭代和增量开发。使用增量开发一次开发应该功能的几个小组 。每一轮的开发都是基于前一次的功能，增加为产品增值的新功能。这时，你就可以发布或者演示产品。
* 迭代开发是在小且重复的周期里，你完成各种开发任务：分析、设计、实现、测试和获得反馈，所以叫作迭代。
* 迭代的结婚就标记一个里程碑。这时，产品也许可用，也许不可用。在迭代结束时，新的功能全部完成，你就可以发布，让用户真正地使用，同时提供技术支持、培训和维护方面的资源。每次增加的新功能都会包含多次迭代。

==== 给我一份详细的长期计划，我就会给你一个注定完蛋的项目。
* 大型系统 的开发是一件非常危险的事情。大型系统更容易 失败。它们通常不遵守迭代和增量开发的计划，或者迭代时间太长。软件开发不是精细 的制造业，而是创新活动。规划几年之后 客户才能十使用的项目注定是行不通的。
* 对付大项目，最理想的办法就是小步前进，这也是敏捷方法的核心。大步跳跃大大地增加了风险，小步前进才可以原盘一你很好地把握平衡。
* 在你周围，可以看到很多迭代和增量开发的例子。比如：W3C提出的XML规范DTD。它用来定义XML文档的词汇和结构，作为原规范的部分发布。虽然在DTD设计的时候就解决了很多问题，但是在真正使用的时候，又显现出很多问题和限制。基于用户的反馈对分外一有了更深一层的理解，这样就诞生了更加高效的第二代解决方案，如：Schema.如果他们一开始就试图进行一些完美的设计，也许就看不到XML成为今天的主流了--我们通过提早发布获得了灼见
和经验。
* 大部分用户都是希望现在就有一个够用的软件，而不是在一年之后得到一个超级好的软件。确定使产品可用的核心功能，然后把他们放在生死关头环境中，越早交到用户的手里越好。
* 根据产品的特性，发布新的功能需要几周或者几个月的时间。如果是打算一年或者两年再交付，你就应该重新评估和重新计划。也许你要说，构建 复杂 的系统需要花费时间，你无法用增量的方式开发一个大型的系统 。如果这种情况成立，就不要生产大的系统 。可以把他分解 成一块块有用的小系统 --再进行增量开发。即使是美国国家航空航天局也使用迭代和增量开发方式开发用于航天飞机的复杂软件。
* 询问用户，哪 些是使产品可用且不可缺少的核心功能。不要为所有可能 需要的华丽功能而分心，不要沉迷于你的想象，去做那些华而不实的用户界面。
* 有一堆的理由，值得你尽快把软件交到用户手中：只要交到用户手里，你就有了收入，这样就有更好的理由继续为产品投资了。从用户那里得到的反馈，会让我们进一步理解 什么是用户真正想要的，以及下一步该实现哪 些功能。也许你会发现，一些过去认为重要的功能，现在已经不再重要了--我们都知道市场的变化 有多块。尽快发布你的应用，迟了也许它就没有用了。
* 使用短迭代和增量开发，可以让开发者更加专注于自己的工作。如果另人告诉你有一年的时间来完成系统 ，你会觉得时间很长。如果目标很遥远，就望更快地风到有形的东西。这不一定是坏事，相反，它会是一件好事，只要把它转化成生产率和下面的反馈。

#增量开发。# 发布带有最小却可用功能块的产品。每个增量开发中，使用1-4周左右迭代周期。

==== 切身感受
* 短迭代让人感觉非常专注且具效率。你能看到一个实际 并且确切的目标。严格的最终期限迫使你做出一些艰难 的决策，没有遗留下长期悬而未决的问题。

==== 平衡的艺术
* 关于迭代时间长短一直是一个有争议的问题，曾经遇到这样一位客户：他们坚持 认为迭代就是4周的时间，因为这是他们学到的。但他们的团队却因为这样的步伐垂死挣扎，因为他们无法在开发新的代码的同时又要维护很多已经完成了的代码。解决方案是，在每4周的迭代蹭安排 一周的维护任务。没有规定说迭代必须要紧挨着下一个迭代。
* 如果每个迭代的时间都不够用，要么是任务太大，要么是迭代的时间太短。把握 好自己的节奏。
* 如果 发布的功能背离了用户的需要，那么多半是因为迭代的周期太长了。用户的需要、技术和我们对需求的理解 ，都会随着时间的失衡而变化 ，在项目发布的时候需要清楚地反映出这些变化 。如果你发现自己工作时还带有过时的观点和陈腐的想法，那么很可能 你等待太长时间做调整了。
* 增量的发布必须是可用的，并且能为用户提供价值。你怎么知道用户会觉得有价值呢？这当然要去问用户。

=== 固定的价格就意味者背叛承诺

== 敏捷反馈

=== 守护天使

=== 先用它再实现它

=== 不同环境，就有不同问题

=== 自动验收测试

=== 试题真实的进度

=== 倾听用户的声音

== 敏捷编码

=== 代码要清晰地表达意图

=== 用代码沟通

=== 动态评估取舍

=== 增量式编程

=== 保持简单

=== 编写内聚的代码

=== 告知，不要询部

=== 根据契约进行替换

== 敏捷调试

=== 记录问题解决日志

=== 警告就是错误

=== 对问题各个击破

=== 报告所有的异常

=== 提供有用的错误信息

== 敏捷协作

=== 定期安排会面时间

=== 架构师必须写代码

=== 实行代码集体所有制

=== 成为指导者

=== 允许大家自己想办法

=== 准备好后再共享代码

=== 做代码复查

=== 及时通报进展与问题

== 走向敏捷

=== 只要一个新的习惯

=== 拯救濒临失败的项目

