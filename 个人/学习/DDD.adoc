


= DDD（领域驱动设计）
:stem: latexmath
:icons: font
:source-highlighter: highlight.js
:sectnums:
:sectlinks:
:sectnumlevels: 4
:toc: left
:toc-title: 目录
:toclevels: 3  

== 战略篇

=== 什么是架构设计

* 设计首先是要解决问题的复杂度
* 其次是要建立团队协作沟通的共识
* 实质是让系统能够更快地响应外界业务的变化 ，并且使得系统能够持续演进


==== 面向业务变化而架构

. 让我们的组件划分尽量靠近变化的原点，对于互联网来说就是用户和业务，这样的划分能够让我们将变化“隔离”在一定的范围（组件）内，从而帮助我们有效减少改变点。
. 组件之间能够互相调用，但彼此之间不应该有强依赖，即各自完成的业务是相对独立的，不会因为一方掉线而牵连另外一方，比如新闻网站挂掉了，聊天网站应该继续正常提供服务，可能提示用户暂时无法提供新闻信息而已。
. 组件在业务上是鼓励利用的，正是这样的利用才成就了今天的互联网，我们不会每个网站都去实现一个强大的搜索引擎。而被复用最多的网站显然会受到追捧，成为明星业务。当然架构上这样的网站必然是健壮的。

* 从业务出发、面向业务变化是我们现代架构设计成功的关键。架构设计的核心实质是保证面对业务变化时我们能够胡足够快的响应能力。

* 面向业务变化 而架构就要求先理解业务的核心问题，即有针对 性地进行关注点分离来找到相对内聚的业务活动形成子问题域。子问题域内部是相对稳定的，即未来的变化 频率不会很高，而子问题边界很容易变化的，比如在一个物流系统中：计算货物从A地到B地的路径是相对固定的，计算包裹的体积及归类 也是相对固定的，但根据包裹的体积优化路径却经常会根据业务条件而变化。

==== 打造架构响应力的方法


[plantuml]
----
:领域专家和开发团队: as team
note top
问题域
+
业务愿望
endnote

[通用语言] as language

team --> language :理解领域语言

[领域知识] as knowledeg

team --> knowledeg 

knowledeg --> language :用来描述

[子域] as subdomain

knowledeg --> subdomain

[核心子域] as core
knowledeg --> core

subdomain -- core

[域模型] as model



----


. 让团队中各个角色（从业务到开发测试）都能够采用统一的架构语言，从而避免组件划分过程中的边界错位。
. 让业务架构和系统架构形成绑定关系，从而建立针对 业务变化 的高响应力架构。

* 在 #战略# 层面，DDD非常强调针对 业务问题的分析和分解，通过识别核心问题域来降低分析的复杂度。
* 在 #战术# 层面，DDD通过强调识别问题域里的不同业务上下文来进行面向业务需求的组件化。
* 最后在实现层面利用成熟的技术模式屏蔽掉技术细节的复杂度。


== 战术篇

=== 业务对象的抽象

==== 讲故事

. 找到一些关键业务对象，在开始进行抽象前一个必须的步骤就是”讲故事“
. 讲什么故事呢？关于这个了域解决的业务问题或者提供的业务能力的故事。即然是故事，就必须有清晰的业务场景和业务对象之间的交互。
. 当能够讲清业务场景的时候，才应该开始抽象的步骤。对于一个业务对象，我们觉的抽象可以是实体和值对象
.. 实体需要给予一个唯一标识，有一个完整的生命周期。

=== 聚合的封装

. 每个聚合都是内聚性很高的组合。聚合本身完成了我们对骨干业务规则 的封闭，减少了我们实现过程中出错的可能。

=== 领域服务的定义
. 服务
. 存储
. 限界上下文

=== 实战篇


== 通用语言、领域、限界上下文

=== 通用语言

* 技术人员使用业务人员的用语作为开发词汇
* 划分好聚合, 将这些词汇关联到聚合上
* 技术人员要将这些词汇映射 到代码实现中
* 这些词汇会随着项目的发展一点点扩展


==== 领域
* 定义：系统要解决的实际问题相关的东西的集合。所有和业务相关的东西都属于领域。
* 领域分为问题域和解决方案域
** 问题域
. 为了区分分部量域的复杂度，问题域被拆解为多个子域，第个子域都要明确待解决的业务问题和业务流程，以及通过解决业务问题为企业带来了什么样的业务价值

** 解决方案域

* 在清晰的定义子域后，我们就可以建立通用语言来提取该子域的领域知识，并基于通用语言为解决问题建立领域模型

* 一个领域模型会存在于一个限界 上下文中。限界 上下文在DDD中用来定义模型的适用范围、模型的用途、以及在休息保持一致，限界上下文会让团队明确模型的职责边界是什么。同时，通用语言被限定在限界上下文中；限界上下文提供了一个语言边界，在每个限界 上下文通用语言的每个词汇必须 和领域概念一一对应。

* 理想条件下，子域和限界上下文是一一对应的，但是子域划分的精度 ，遗留系统折现状，语言的歧义，团队结构等子域和限界 上下文对应可能是1：N或者N:N
* 通过限界上下文间的映射 ，上下文中的多个模型会协作 以满足系统需求。我们也可以了解在不同上下文中的同名词汇是否存在关系，存在什么样的关系。
* 对通用语言而言，子域解释了通用语言和现实世界业务活动的关系；限界上下文提供了一个语义边界，来保持能用语言和领域概念的一一对应关系；上下文映射则提供了不同限界上下中的通用语言的转换关系


== 架构


== 微服务

=== 领域划分的原则

. 依据该模型与边界内其他模型或角色关系的紧密程度。比如，是否该模型变化 时其其他模型也需要进行变化 ；该数据是否通常由当前上下文中的角色 在当前 活动范围内使用。
. 服务边界内的业务能力职责 应单一，不是完成同一业务能力的醋不放在同一个上下文中。
. 划分的子域和服务需满足正交原则 。领域名字代表的自然语言上下文保持互相独立。
. 读写分享的原则
. 醋在很多业务操作中同时被修改和更新。
. 组织中业务部分的划分也是一种参考，一个业务部门的存在往往有其独特的业务价值。


=== 领域划分的误区和建议

* 业务能力还是计算能力？
----
  在划分一些貌似通用的领域时，其实只是用到了通用的计算能力而不是业务能力，只需采用通用库的方式进行封装，而无需使用服务的方式。如我们系统的模板服务，是构建 通用的模板服务，服好务 于整体平台的服务；还是每个服务拥有独立的模板模块。
----


* 尽早识别剥离通用领域。
----
  如身份认证与鉴权领域，是企业系统中最复杂、有相对多变的领域，需要及早隔离它对核心业务的干扰。
----

* 时刻促成技术人员与客户、业务人员的对话。
----
  业务领域的划分离不开对业务意图的真正理解。而需求人员和体验设计师对于用户操作更熟悉，而技术人员、业务分析师对领域驱动设计、事件风暴更熟悉。不管那种方法都要求跨角色 的群体协同工作，即客户人员、业务分析师、体验设计师与技术人员、架构师。而现实情况中，用户行为更多的在初始阶段，在需求阶段进行，而领域驱动 设计、事件风暴更多的在开发设计阶段被使用，故而需求阶段经常缺失技术人员，而开发设计阶段经常缺失客户、业务人员的参与。另一个觉现象是，初始过程参与人员和真正的开发团队有可能 不是同一个群体，那么在初始中的业务沟通往往以UI的方式作为传递，因此在开发中经常只能通过UYI设计来理解 业务的真正意图。所以人要想将正确的理解 业务，做对软件，需要时刻促成技术人员与客户、业务人员的对话。
----


=== 拆分方法与策略
* 绞杀者模式：指在遗留系统外围，将新功能用新的方式构建为新 热播讨论。随着时间的推移经，新的服务逐渐“绞杀”老的遗留系统。对于那些老旧庞大难以更改的遗留系统，推荐采用绞杀者模式。

* 修缮者模式： 就如修房子或修路一样，将老旧待修缮的部分进行隔离，用新的方式对其进行单独修改。修复的同时，需保证与其他部分仍能协同功能。


* 总结：“旧的不变，新的创建，一步切换，旧的再见”

=== 拆分步骤

* 对于模块的拆分包括两部分：数据库与业务代码，可以先数据库后业务代码，亦可先业务代码后数据库。然而我们的项目拆分中遇到的最大挑战是数据层的拆分。数据库层由于进行系统性能高估的驱动 ，在代码中出现了跨模块的数据库连表查询。这导致后期服务的拆分非常困难。因此在拆分 步骤上我们更多的推荐数据库行先。

* 数据库拆分 

[plantuml]
----
[单体结构] as single
[代码分离] as  code
single -right->code
[同步数据] as sync
code -right->sync
[逐渐迁移读api] as remove
sync -down-> remove

[拆分完成]  as success
remove -left-> success
----

* 拆分 后业务变了增加了怎么办？
. 客户的业务在变化 的，我们对业务的认知也是逐渐的过程。
. 系统的初期建议以单体结构开始，随业务发展决定期是否被拆分或合并。
. 意味着这样构建 的服务在它的生命周期中必然会持续被拆分 或合并。
. 为了实现这个目标，使系统拥有快速的响应力，也要求这样的拆分 必然是高效的低成本的。
. 服务的设计需要满足的原则：

** 服务要有明确的业务边界，以单体开始并不意味着没有边界。服务要有边界，即使以单体开始，也要定义单体时期的边界。
** 服务要有明确清晰的契约设计，即对外提供的业务能力。
** 服务内部要保持高度模块化，才能够容易的被拆分
** 可测试 

* 如何安全地持续地拆？
** 坏味道驱动 ，架构 的坏味道是代码坏味道在更高层次的展现，也就意味着架构 的混乱 程度同样反映了该系统代码层的质量问题。
** 安全小步的重构。
** 有足够的测试进行保护--契约测试。
** 持续验证演进的方向。

* 如何保证拆对了？
----
  系统可由单体结构开始，不断的演进。而团队需要对业务保持敏感，与客户、业务人员进行业务圣诞，不断修炼领域驱动设计和重构的能力。
  在拆分的路上，我们的经验显示 其最大的障碍来自意大利面一样的系统。不管我们是什么样的架构风格，高内聚低偶和的模块化代码内部质量仍然是我们架构演进的基石。具有夯实领域驱动 设计和重构功底的团队才可以应对这些挑战，持续演进，保持其生命力。而架构变迁之前需要弄清背后的变迁动因与价值，探索性前进，及时反馈验证，才是正解。
  勿忘初心、且行且演进。
----

== 示例实现

=== 从写到Readme开始

* 一份好的README可以给人以项目合影概览，可以使新人快速上手项目，可以降低沟通成本。同时，README应该简明扼要，条理清晰，建议包含以下方面：
** 项目简介：用一两句话简单描述该项目所实现的业务功能；
** 技术选型：列出项目的技术栈，包括语言、框架和中间件等；
** 本地构建：列出本地开发过程中所用到的工具命令；
** 领域模型：核心的概念比如对电商系统来说有ORDER、Product等；
** 测试策略：自动化测试如何分类，哪些必须写测试，哪些没有必要写测试；
** 技术架构：技术架构图；
** 部署架构：部署架构图；
** 外部依赖：项目运行时所依赖的外部集成方，比如订单系统会依赖于会员系统；
** 环境信息：各个环境的访问方式，数据库连接等；
** 编码实践：统一的编码实践，比如异常处理原则、分布封装等；
** FAQ：开发过程中觉问题的解答。

=== 消费领域事件

* 在事件消费时，除了完成基本的消费逻辑外，我们需要重点关注以下两点：
** 消费方的冥等性
** 消费有可能进一步产生事件

=== 事件驱动架构的2种风格
* 事件通知
** 优点：
. 设计简单，通常只需要携带聚合根的ID即可。
. 进一步降低了事件驱动 系统中的耦合度

** 缺点
. 消费方需要的数据依然需要额外的API调用从发布方获取，这一定程度上增加了系统之间的耦合性
. 如果源系统宕机，消费方也无法完成后续操作

[plantuml]
----
[发送方] as send

package 消费方{
  [事件] as event
  send --> event :1 发送方发布事件
  [事件处理] as  do
  event --> do :2 消费方接受事件并处理
  send --> do : 3 消费方调用发布方的API以获取事件相关数据
  database db as db
  do --> db :4  消费方更新自身状态
}
----


* 事件携带状态转移

[plantuml]
----
[发送方] as send

package 消费方{
  [事件] as event
  send -right-> event
  [事件处理] as do
  event -right-> do  
  database db 
  do -right->db
}
----