= 常用算法
:stem: latexmath
:icons: font
:source-highlighter: highlight.js
:sectnums:
:sectlinks:
:sectnumlevels: 4
:toc: left
:toc-title: 目录
:toclevels: 3  

== 冒泡排序

* 思路
```
从等待排序序列中找出一个最大值或一个最小值，这样操作执行n-1次最终 就可以得到一个有序序列
```

== 插入排序

* 思路
```
初始状态下，将一个元素看作是有序子序列，从第二个元素开始在不破坏子序列有序情况下，将后续每个元素插入合适位置
```

== 选择排序

* 思路
```
每次从待排序序列中找出最大值 或最小值 ，查找过程重复n-1次。对于每次找到的最大值 或最小值 ，通过交换元素位置的方式将它们旋转到适当的位置，最终使整个序列变成有序序列。
```

== 希尔排序

* 思路
. 将待排序序列划分成多个子序列，使用普通的插入排序算法对每个子序列进行排序
. 按照不同的划分标准，重复执行第一步
. 使用普通的插入排序算法对整个序列进行排序

== 归并排序

* 思路
. 将整个待排序序列划分成多个不可再分的子序列，每个子序列中仅有一个元素
. 所有的子序列进行两两合并，合并过程中完成排序排序，最终合并得到的新序列就是有序序列

== 快速排序

* 思路
. 从待排序序列中任选一个元素作为蹭元素，将所有比所选元素小的移动到它的左边，所有比所选元素大的移动到它的右边
. 所选左右两边的子序列看作是两个待排序序列主，各自重复第一步。直到所有的子序列都不可再分（公包含1个元素或者不包含任何元素），整个序列就变成了一个有序序列

== 计数排序

* 思路
. 找到序列中的最大值 （用max表示）
. 创建一个长度为max+1,元素初始值全为0的数组,为数据[1，max]区域内的各个空间建立索引:找到序列中最小值 （用min表示）,作为数组下标为1的存储空间的索引 +

** 将max作为数组下标为max的存储空间的索引
** 将max-1作为数组下标为max-1的存储空间的索引
** 将max-2作为数组下标为max-2的存储空间的索引
** ......

+
. 统计待排序序列中各个元素的出现 次数，存储到以该元素为索引的数组空间中
. 进一步加工数组中存储的数据。从数据下标为1的位置开始，按照公式：array[i]=array[i-1]+array[i] 修改数组中元素，其中i的取值范围为[1,max]
. 遍历待排序序列中的元素，以该元素为索引获取数组中存储的值，此值即为序列排序后元素应处的位置
. 当确定了一个元素排序后的位置，需要将数组中该元素为索引对应的值减去1